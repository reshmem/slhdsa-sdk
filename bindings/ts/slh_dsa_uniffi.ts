// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from "./slh_dsa_uniffi-ffi";
import {
  type UniffiByteArray,
  AbstractFfiConverterByteArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiInternalError,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
} from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.

export function slhDsaKeypairGenerate(param: ParameterSetId): Keypair {
  return FfiConverterTypeKeypair.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_keypair_generate(
          FfiConverterTypeParameterSetId.lower(param),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
export function slhDsaParameterName(param: ParameterSetId): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_parameter_name(
          FfiConverterTypeParameterSetId.lower(param),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
export function slhDsaSign(
  param: ParameterSetId,
  signingKey: ArrayBuffer,
  msg: ArrayBuffer,
  ctx: ArrayBuffer,
): SignResult {
  return FfiConverterTypeSignResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_sign(
          FfiConverterTypeParameterSetId.lower(param),
          FfiConverterArrayBuffer.lower(signingKey),
          FfiConverterArrayBuffer.lower(msg),
          FfiConverterArrayBuffer.lower(ctx),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
export function slhDsaSignDeterministic(
  param: ParameterSetId,
  signingKey: ArrayBuffer,
  msg: ArrayBuffer,
  ctx: ArrayBuffer,
): SignResult {
  return FfiConverterTypeSignResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_sign_deterministic(
          FfiConverterTypeParameterSetId.lower(param),
          FfiConverterArrayBuffer.lower(signingKey),
          FfiConverterArrayBuffer.lower(msg),
          FfiConverterArrayBuffer.lower(ctx),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
export function slhDsaSignatureLen(param: ParameterSetId): /*u64*/ bigint {
  return FfiConverterUInt64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_signature_len(
          FfiConverterTypeParameterSetId.lower(param),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
export function slhDsaSigningKeyLen(param: ParameterSetId): /*u64*/ bigint {
  return FfiConverterUInt64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_signing_key_len(
          FfiConverterTypeParameterSetId.lower(param),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
export function slhDsaVerify(
  param: ParameterSetId,
  verifyingKey: ArrayBuffer,
  msg: ArrayBuffer,
  ctx: ArrayBuffer,
  signature: ArrayBuffer,
): VerifyResult {
  return FfiConverterTypeVerifyResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_verify(
          FfiConverterTypeParameterSetId.lower(param),
          FfiConverterArrayBuffer.lower(verifyingKey),
          FfiConverterArrayBuffer.lower(msg),
          FfiConverterArrayBuffer.lower(ctx),
          FfiConverterArrayBuffer.lower(signature),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
export function slhDsaVerifyingKeyFromSigningKey(
  param: ParameterSetId,
  signingKey: ArrayBuffer,
): KeyResult {
  return FfiConverterTypeKeyResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_verifying_key_from_signing_key(
          FfiConverterTypeParameterSetId.lower(param),
          FfiConverterArrayBuffer.lower(signingKey),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
export function slhDsaVerifyingKeyLen(param: ParameterSetId): /*u64*/ bigint {
  return FfiConverterUInt64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_slh_dsa_uniffi_fn_func_slh_dsa_verifying_key_len(
          FfiConverterTypeParameterSetId.lower(param),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}

export type KeyResult = {
  status: SlhDsaStatus;
  verifyingKey: ArrayBuffer;
};

/**
 * Generated factory for {@link KeyResult} record objects.
 */
export const KeyResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<KeyResult, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link KeyResult}, with defaults specified
     * in Rust, in the {@link slh_dsa_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link KeyResult}, with defaults specified
     * in Rust, in the {@link slh_dsa_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link slh_dsa_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<KeyResult>,
  });
})();

const FfiConverterTypeKeyResult = (() => {
  type TypeName = KeyResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        status: FfiConverterTypeSlhDsaStatus.read(from),
        verifyingKey: FfiConverterArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSlhDsaStatus.write(value.status, into);
      FfiConverterArrayBuffer.write(value.verifyingKey, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSlhDsaStatus.allocationSize(value.status) +
        FfiConverterArrayBuffer.allocationSize(value.verifyingKey)
      );
    }
  }
  return new FFIConverter();
})();

export type Keypair = {
  signingKey: ArrayBuffer;
  verifyingKey: ArrayBuffer;
};

/**
 * Generated factory for {@link Keypair} record objects.
 */
export const Keypair = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Keypair, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Keypair}, with defaults specified
     * in Rust, in the {@link slh_dsa_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Keypair}, with defaults specified
     * in Rust, in the {@link slh_dsa_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link slh_dsa_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Keypair>,
  });
})();

const FfiConverterTypeKeypair = (() => {
  type TypeName = Keypair;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        signingKey: FfiConverterArrayBuffer.read(from),
        verifyingKey: FfiConverterArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.signingKey, into);
      FfiConverterArrayBuffer.write(value.verifyingKey, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(value.signingKey) +
        FfiConverterArrayBuffer.allocationSize(value.verifyingKey)
      );
    }
  }
  return new FFIConverter();
})();

export type SignResult = {
  status: SlhDsaStatus;
  signature: ArrayBuffer;
};

/**
 * Generated factory for {@link SignResult} record objects.
 */
export const SignResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SignResult, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SignResult}, with defaults specified
     * in Rust, in the {@link slh_dsa_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SignResult}, with defaults specified
     * in Rust, in the {@link slh_dsa_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link slh_dsa_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SignResult>,
  });
})();

const FfiConverterTypeSignResult = (() => {
  type TypeName = SignResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        status: FfiConverterTypeSlhDsaStatus.read(from),
        signature: FfiConverterArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSlhDsaStatus.write(value.status, into);
      FfiConverterArrayBuffer.write(value.signature, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSlhDsaStatus.allocationSize(value.status) +
        FfiConverterArrayBuffer.allocationSize(value.signature)
      );
    }
  }
  return new FFIConverter();
})();

export type VerifyResult = {
  status: SlhDsaStatus;
  valid: boolean;
};

/**
 * Generated factory for {@link VerifyResult} record objects.
 */
export const VerifyResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VerifyResult, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VerifyResult}, with defaults specified
     * in Rust, in the {@link slh_dsa_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VerifyResult}, with defaults specified
     * in Rust, in the {@link slh_dsa_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link slh_dsa_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VerifyResult>,
  });
})();

const FfiConverterTypeVerifyResult = (() => {
  type TypeName = VerifyResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        status: FfiConverterTypeSlhDsaStatus.read(from),
        valid: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSlhDsaStatus.write(value.status, into);
      FfiConverterBool.write(value.valid, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSlhDsaStatus.allocationSize(value.status) +
        FfiConverterBool.allocationSize(value.valid)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status,
      ),
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status,
      ),
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status,
      ),
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

export enum ParameterSetId {
  Shake128s,
  Shake128f,
  Shake192s,
  Shake192f,
  Shake256s,
  Shake256f,
  Sha2128s,
  Sha2128f,
  Sha2192s,
  Sha2192f,
  Sha2256s,
  Sha2256f,
}

const FfiConverterTypeParameterSetId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ParameterSetId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ParameterSetId.Shake128s;
        case 2:
          return ParameterSetId.Shake128f;
        case 3:
          return ParameterSetId.Shake192s;
        case 4:
          return ParameterSetId.Shake192f;
        case 5:
          return ParameterSetId.Shake256s;
        case 6:
          return ParameterSetId.Shake256f;
        case 7:
          return ParameterSetId.Sha2128s;
        case 8:
          return ParameterSetId.Sha2128f;
        case 9:
          return ParameterSetId.Sha2192s;
        case 10:
          return ParameterSetId.Sha2192f;
        case 11:
          return ParameterSetId.Sha2256s;
        case 12:
          return ParameterSetId.Sha2256f;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ParameterSetId.Shake128s:
          return ordinalConverter.write(1, into);
        case ParameterSetId.Shake128f:
          return ordinalConverter.write(2, into);
        case ParameterSetId.Shake192s:
          return ordinalConverter.write(3, into);
        case ParameterSetId.Shake192f:
          return ordinalConverter.write(4, into);
        case ParameterSetId.Shake256s:
          return ordinalConverter.write(5, into);
        case ParameterSetId.Shake256f:
          return ordinalConverter.write(6, into);
        case ParameterSetId.Sha2128s:
          return ordinalConverter.write(7, into);
        case ParameterSetId.Sha2128f:
          return ordinalConverter.write(8, into);
        case ParameterSetId.Sha2192s:
          return ordinalConverter.write(9, into);
        case ParameterSetId.Sha2192f:
          return ordinalConverter.write(10, into);
        case ParameterSetId.Sha2256s:
          return ordinalConverter.write(11, into);
        case ParameterSetId.Sha2256f:
          return ordinalConverter.write(12, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum SlhDsaStatus {
  Ok,
  InvalidParam,
  InvalidLength,
  DecodeError,
  VerifyFailed,
}

const FfiConverterTypeSlhDsaStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SlhDsaStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SlhDsaStatus.Ok;
        case 2:
          return SlhDsaStatus.InvalidParam;
        case 3:
          return SlhDsaStatus.InvalidLength;
        case 4:
          return SlhDsaStatus.DecodeError;
        case 5:
          return SlhDsaStatus.VerifyFailed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SlhDsaStatus.Ok:
          return ordinalConverter.write(1, into);
        case SlhDsaStatus.InvalidParam:
          return ordinalConverter.write(2, into);
        case SlhDsaStatus.InvalidLength:
          return ordinalConverter.write(3, into);
        case SlhDsaStatus.DecodeError:
          return ordinalConverter.write(4, into);
        case SlhDsaStatus.VerifyFailed:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_slh_dsa_uniffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion,
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_keypair_generate() !==
    7757
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_keypair_generate",
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_parameter_name() !==
    63153
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_parameter_name",
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_sign() !==
    51560
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_sign",
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_sign_deterministic() !==
    23979
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_sign_deterministic",
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_signature_len() !==
    62991
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_signature_len",
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_signing_key_len() !==
    40535
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_signing_key_len",
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_verify() !==
    22241
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_verify",
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_verifying_key_from_signing_key() !==
    64766
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_verifying_key_from_signing_key",
    );
  }
  if (
    nativeModule().ubrn_uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_verifying_key_len() !==
    16179
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_slh_dsa_uniffi_checksum_func_slh_dsa_verifying_key_len",
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeKeyResult,
    FfiConverterTypeKeypair,
    FfiConverterTypeParameterSetId,
    FfiConverterTypeSignResult,
    FfiConverterTypeSlhDsaStatus,
    FfiConverterTypeVerifyResult,
  },
});
